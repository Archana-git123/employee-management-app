import { c } from "react-compiler-runtime";
import { useEffect } from "react";
import { createStore } from "zustand";
import { HistoryStore as HistoryStore$1 } from "@graphiql/toolkit";
import { pick, useGraphiQL, createBoundedUseStore } from "@graphiql/react";
const historyStore = createStore((set, get) => ({
  historyStorage: null,
  actions: {
    addToHistory(operation) {
      const {
        historyStorage
      } = get();
      historyStorage == null ? void 0 : historyStorage.updateHistory(operation);
      set({});
    },
    editLabel(operation, index) {
      const {
        historyStorage
      } = get();
      historyStorage == null ? void 0 : historyStorage.editLabel(operation, index);
      set({});
    },
    toggleFavorite(operation) {
      const {
        historyStorage
      } = get();
      historyStorage == null ? void 0 : historyStorage.toggleFavorite(operation);
      set({});
    },
    setActive: (item) => item,
    deleteFromHistory(item, clearFavorites) {
      const {
        historyStorage
      } = get();
      historyStorage == null ? void 0 : historyStorage.deleteHistory(item, clearFavorites);
      set({});
    }
  }
}));
const HistoryStore = (t0) => {
  const $ = c(11);
  const {
    maxHistoryLength: t1,
    children
  } = t0;
  const maxHistoryLength = t1 === void 0 ? 20 : t1;
  let t2;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t2 = pick("isFetching", "tabs", "activeTabIndex", "storage");
    $[0] = t2;
  } else {
    t2 = $[0];
  }
  const {
    isFetching,
    tabs,
    activeTabIndex,
    storage
  } = useGraphiQL(t2);
  const activeTab = tabs[activeTabIndex];
  let t3;
  if ($[1] !== maxHistoryLength || $[2] !== storage) {
    t3 = new HistoryStore$1(storage, maxHistoryLength);
    $[1] = maxHistoryLength;
    $[2] = storage;
    $[3] = t3;
  } else {
    t3 = $[3];
  }
  const historyStorage = t3;
  let t4;
  let t5;
  if ($[4] !== historyStorage) {
    t4 = () => {
      historyStore.setState({
        historyStorage
      });
    };
    t5 = [historyStorage];
    $[4] = historyStorage;
    $[5] = t4;
    $[6] = t5;
  } else {
    t4 = $[5];
    t5 = $[6];
  }
  useEffect(t4, t5);
  let t6;
  let t7;
  if ($[7] !== activeTab || $[8] !== isFetching) {
    t6 = () => {
      if (!isFetching) {
        return;
      }
      const {
        addToHistory
      } = historyStore.getState().actions;
      addToHistory({
        query: activeTab.query ?? void 0,
        variables: activeTab.variables ?? void 0,
        headers: activeTab.headers ?? void 0,
        operationName: activeTab.operationName ?? void 0
      });
    };
    t7 = [isFetching, activeTab];
    $[7] = activeTab;
    $[8] = isFetching;
    $[9] = t6;
    $[10] = t7;
  } else {
    t6 = $[9];
    t7 = $[10];
  }
  useEffect(t6, t7);
  return children;
};
const useHistoryStore = createBoundedUseStore(historyStore);
const EMPTY_ARRAY = [];
const useHistory = () => {
  return useHistoryStore(_temp);
};
const useHistoryActions = () => {
  return useHistoryStore(_temp2);
};
function _temp(state) {
  var _a;
  return ((_a = state.historyStorage) == null ? void 0 : _a.queries) ?? EMPTY_ARRAY;
}
function _temp2(state) {
  return state.actions;
}
export {
  HistoryStore,
  useHistory,
  useHistoryActions
};
//# sourceMappingURL=context.js.map
