{"version":3,"file":"editor.js","sources":["../../src/stores/editor.ts"],"sourcesContent":["import type { StateCreator } from 'zustand';\nimport type {\n  FragmentDefinitionNode,\n  OperationDefinitionNode,\n  DocumentNode,\n} from 'graphql';\nimport type { OperationFacts } from 'graphql-language-service';\nimport { MaybePromise, mergeAst } from '@graphiql/toolkit';\nimport { print } from 'graphql';\nimport {\n  createTab,\n  setPropertiesInActiveTab,\n  TabDefinition,\n  TabsState,\n  TabState,\n  clearHeadersFromTabs,\n  serializeTabState,\n} from '../utility/tabs';\nimport type { SlicesWithActions, MonacoEditor } from '../types';\nimport { debounce, formatJSONC } from '../utility';\nimport { STORAGE_KEY } from '../constants';\n\nexport interface EditorSlice extends TabsState {\n  /**\n   * Unique ID of the GraphiQL instance, which will be suffixed to the URIs for operations,\n   * variables, headers, and response editors.\n   *\n   * @see https://github.com/microsoft/monaco-editor#uris\n   */\n  uriInstanceId: string;\n  /**\n   * The Monaco Editor instance used in the request headers editor, used to edit HTTP headers.\n   */\n  headerEditor?: MonacoEditor;\n\n  /**\n   * The Monaco Editor instance used in the operation editor.\n   */\n  queryEditor?: MonacoEditor;\n\n  /**\n   * The Monaco Editor instance used in the response editor.\n   */\n  responseEditor?: MonacoEditor;\n\n  /**\n   * The Monaco Editor instance used in the variables editor.\n   */\n  variableEditor?: MonacoEditor;\n\n  /**\n   * The contents of the request headers editor when initially rendering the provider\n   * component.\n   */\n  initialHeaders: string;\n\n  /**\n   * The contents of the operation editor when initially rendering the provider\n   * component.\n   */\n  initialQuery: string;\n\n  /**\n   * The contents of the variables editor when initially rendering the provider\n   * component.\n   */\n  initialVariables: string;\n\n  /**\n   * A map of fragment definitions using the fragment name as a key which are\n   * made available to include in the query.\n   */\n  externalFragments: Map<string, FragmentDefinitionNode>;\n\n  /**\n   * If the contents of the request headers editor are persisted in storage.\n   */\n  shouldPersistHeaders: boolean;\n\n  /**\n   * The initial content of the operation editor when loading GraphiQL and there is\n   * no saved query in storage and no `initialQuery` prop.\n   *\n   * This value is used only for the first tab. Additional tabs will open with\n   * an empty operation editor.\n   *\n   * @default \"# Welcome to GraphiQL...\"\n   */\n  defaultQuery?: string;\n\n  /**\n   * Invoked when the operation name changes. Possible triggers are:\n   * - Editing the contents of the operation editor\n   * - Selecting an operation for execution in a document that contains multiple\n   *   operation definitions\n   * @param operationName - The operation name after it has been changed.\n   */\n  onEditOperationName?(operationName: string): void;\n\n  /**\n   * Invoked when the state of the tabs changes. Possible triggers are:\n   * - Updating any editor contents inside the currently active tab\n   * - Adding a tab\n   * - Switching to a different tab\n   * - Closing a tab\n   * @param tabState - The tab state after it has been updated.\n   */\n  onTabChange?(tabState: TabsState): void;\n\n  /**\n   * Headers to be set when opening a new tab.\n   */\n  defaultHeaders?: string;\n\n  /**\n   * Invoked when the current contents of the operation editor are copied to the\n   * clipboard.\n   * @param query - The content that has been copied.\n   */\n  onCopyQuery?: (query: string) => void;\n\n  /**\n   * Invoked when the prettify callback is invoked.\n   * @param query - The current value of the operation editor.\n   * @default\n   * import prettier from 'prettier/standalone'\n   *\n   * prettier.format(query, { parser: 'graphql' })\n   * @returns The formatted query.\n   */\n  onPrettifyQuery: (query: string) => MaybePromise<string>;\n\n  // Operation facts that are derived from the operation editor.\n\n  /**\n   * @remarks from graphiql 5\n   */\n  documentAST?: OperationFacts['documentAST'];\n\n  /**\n   * @remarks from graphiql 5\n   */\n  operationName?: string;\n\n  /**\n   * @remarks from graphiql 5\n   */\n  operations?: OperationFacts['operations'];\n}\n\nexport interface EditorActions {\n  /**\n   * Add a new tab.\n   */\n  addTab(): void;\n\n  /**\n   * Switch to a different tab.\n   * @param index - The index of the tab that should be switched to.\n   */\n  changeTab(index: number): void;\n\n  /**\n   * Move a tab to a new spot.\n   * @param newOrder - The new order for the tabs.\n   */\n  moveTab(newOrder: TabState[]): void;\n\n  /**\n   * Close a tab. If the currently active tab is closed, the tab before it will\n   * become active. If there is no tab before the closed one, the tab after it\n   * will become active.\n   * @param index - The index of the tab that should be closed.\n   */\n  closeTab(index: number): void;\n\n  /**\n   * Update the state for the tab that is currently active. This will be\n   * reflected in the `tabs` object and the state will be persisted in storage\n   * (if available).\n   * @param partialTab - A partial tab state object that will override the\n   * current values. The properties `id`, `hash` and `title` cannot be changed.\n   */\n  updateActiveTabValues(\n    partialTab: Partial<Omit<TabState, 'id' | 'hash' | 'title'>>,\n  ): void;\n\n  /**\n   * Set the Monaco Editor instance used in the specified editor.\n   */\n  setEditor(\n    state: Pick<\n      EditorSlice,\n      'headerEditor' | 'queryEditor' | 'responseEditor' | 'variableEditor'\n    >,\n  ): void;\n\n  /**\n   * Changes the operation name and invokes the `onEditOperationName` callback.\n   */\n  setOperationName(operationName: string): void;\n\n  /**\n   * Changes if headers should be persisted.\n   */\n  setShouldPersistHeaders(persist: boolean): void;\n\n  storeTabs(tabsState: TabsState): void;\n\n  setOperationFacts(facts: {\n    documentAST?: DocumentNode;\n    operationName?: string;\n    operations?: OperationDefinitionNode[];\n  }): void;\n\n  /**\n   * Copy a query to clipboard.\n   */\n  copyQuery: () => Promise<void>;\n\n  /**\n   * Merge fragments definitions into operation definition.\n   */\n  mergeQuery: () => void;\n\n  /**\n   * Prettify query, variables and request headers editors.\n   */\n  prettifyEditors: () => Promise<void>;\n}\n\nexport interface EditorProps\n  extends Pick<\n    EditorSlice,\n    | 'onTabChange'\n    | 'onEditOperationName'\n    | 'defaultHeaders'\n    | 'defaultQuery'\n    | 'onCopyQuery'\n  > {\n  /**\n   * With this prop you can pass so-called \"external\" fragments that will be\n   * included in the query document (depending on usage). You can either pass\n   * the fragments using SDL (passing a string) or you can pass a list of\n   * `FragmentDefinitionNode` objects.\n   */\n  externalFragments?: string | FragmentDefinitionNode[];\n\n  /**\n   * This prop can be used to define the default set of tabs, with their\n   * queries, variables, and headers. It will be used as default only if\n   * there is no tab state persisted in storage.\n   *\n   * @example\n   * ```tsx\n   * <GraphiQL\n   *   defaultTabs={[\n   *     { query: 'query myExampleQuery {}' },\n   *     { query: '{ id }' }\n   *   ]}\n   * />\n   *```\n   */\n  defaultTabs?: TabDefinition[];\n\n  /**\n   * This prop toggles if the contents of the request headers editor are persisted in\n   * storage.\n   * @default false\n   */\n  shouldPersistHeaders?: boolean;\n\n  onPrettifyQuery?: EditorSlice['onPrettifyQuery'];\n  initialQuery?: EditorSlice['initialQuery'];\n  initialVariables?: EditorSlice['initialVariables'];\n  initialHeaders?: EditorSlice['initialHeaders'];\n}\n\ntype CreateEditorSlice = (\n  initial: Pick<\n    EditorSlice,\n    | 'shouldPersistHeaders'\n    | 'tabs'\n    | 'activeTabIndex'\n    | 'initialQuery'\n    | 'initialVariables'\n    | 'initialHeaders'\n    | 'onEditOperationName'\n    | 'externalFragments'\n    | 'onTabChange'\n    | 'defaultQuery'\n    | 'defaultHeaders'\n    | 'onPrettifyQuery'\n    | 'onCopyQuery'\n    | 'uriInstanceId'\n  >,\n) => StateCreator<\n  SlicesWithActions,\n  [],\n  [],\n  EditorSlice & { actions: EditorActions }\n>;\n\nexport const createEditorSlice: CreateEditorSlice = initial => (set, get) => {\n  function setEditorValues({\n    query,\n    variables,\n    headers,\n    response,\n  }: {\n    query: string | null;\n    variables?: string | null;\n    headers?: string | null;\n    response: string | null;\n  }) {\n    const {\n      queryEditor,\n      variableEditor,\n      headerEditor,\n      responseEditor,\n      defaultHeaders,\n    } = get();\n    queryEditor?.setValue(query ?? '');\n    variableEditor?.setValue(variables ?? '');\n    headerEditor?.setValue(headers ?? defaultHeaders ?? '');\n    responseEditor?.setValue(response ?? '');\n  }\n\n  function synchronizeActiveTabValues(tabsState: TabsState): TabsState {\n    const {\n      queryEditor,\n      variableEditor,\n      headerEditor,\n      responseEditor,\n      operationName,\n    } = get();\n    return setPropertiesInActiveTab(tabsState, {\n      query: queryEditor?.getValue() ?? null,\n      variables: variableEditor?.getValue() ?? null,\n      headers: headerEditor?.getValue() ?? null,\n      response: responseEditor?.getValue() ?? null,\n      operationName: operationName ?? null,\n    });\n  }\n\n  const $actions: EditorActions = {\n    addTab() {\n      set(({ defaultHeaders, onTabChange, tabs, activeTabIndex, actions }) => {\n        // Make sure the current tab stores the latest values\n        const updatedValues = synchronizeActiveTabValues({\n          tabs,\n          activeTabIndex,\n        });\n        const updated = {\n          tabs: [...updatedValues.tabs, createTab({ headers: defaultHeaders })],\n          activeTabIndex: updatedValues.tabs.length,\n        };\n        actions.storeTabs(updated);\n        setEditorValues(updated.tabs[updated.activeTabIndex]!);\n        onTabChange?.(updated);\n        return updated;\n      });\n    },\n    changeTab(index) {\n      set(({ actions, onTabChange, tabs }) => {\n        actions.stop();\n        const updated = {\n          tabs,\n          activeTabIndex: index,\n        };\n        actions.storeTabs(updated);\n        setEditorValues(updated.tabs[updated.activeTabIndex]!);\n        onTabChange?.(updated);\n        return updated;\n      });\n    },\n    moveTab(newOrder) {\n      set(({ onTabChange, actions, tabs, activeTabIndex }) => {\n        const activeTab = tabs[activeTabIndex]!;\n        const updated = {\n          tabs: newOrder,\n          activeTabIndex: newOrder.indexOf(activeTab),\n        };\n        actions.storeTabs(updated);\n        setEditorValues(updated.tabs[updated.activeTabIndex]!);\n        onTabChange?.(updated);\n        return updated;\n      });\n    },\n    closeTab(index) {\n      set(({ activeTabIndex, onTabChange, actions, tabs }) => {\n        if (activeTabIndex === index) {\n          actions.stop();\n        }\n        const updated = {\n          tabs: tabs.filter((_tab, i) => index !== i),\n          activeTabIndex: Math.max(activeTabIndex - 1, 0),\n        };\n        actions.storeTabs(updated);\n        setEditorValues(updated.tabs[updated.activeTabIndex]!);\n        onTabChange?.(updated);\n        return updated;\n      });\n    },\n    updateActiveTabValues(partialTab) {\n      set(({ activeTabIndex, tabs, onTabChange, actions }) => {\n        const updated = setPropertiesInActiveTab(\n          { tabs, activeTabIndex },\n          partialTab,\n        );\n        actions.storeTabs(updated);\n        onTabChange?.(updated);\n        return updated;\n      });\n    },\n    setEditor({ headerEditor, queryEditor, responseEditor, variableEditor }) {\n      const entries = Object.entries({\n        headerEditor,\n        queryEditor,\n        responseEditor,\n        variableEditor,\n      }).filter(([_key, value]) => value);\n      const newState = Object.fromEntries(entries);\n      set(newState);\n    },\n    setOperationName(operationName) {\n      set(({ onEditOperationName, actions }) => {\n        actions.updateActiveTabValues({ operationName });\n        onEditOperationName?.(operationName);\n        return { operationName };\n      });\n    },\n    setShouldPersistHeaders(persist) {\n      const { headerEditor, tabs, activeTabIndex, storage } = get();\n      if (persist) {\n        storage.set(STORAGE_KEY.headers, headerEditor?.getValue() ?? '');\n        const serializedTabs = serializeTabState(\n          { tabs, activeTabIndex },\n          true,\n        );\n        storage.set(STORAGE_KEY.tabs, serializedTabs);\n      } else {\n        storage.set(STORAGE_KEY.headers, '');\n        clearHeadersFromTabs(storage);\n      }\n      storage.set(STORAGE_KEY.persistHeaders, persist.toString());\n      set({ shouldPersistHeaders: persist });\n    },\n    storeTabs({ tabs, activeTabIndex }) {\n      const { shouldPersistHeaders, storage } = get();\n      const store = debounce(500, (value: string) => {\n        storage.set(STORAGE_KEY.tabs, value);\n      });\n      store(serializeTabState({ tabs, activeTabIndex }, shouldPersistHeaders));\n    },\n    setOperationFacts({ documentAST, operationName, operations }) {\n      set({\n        documentAST,\n        operationName,\n        operations,\n      });\n    },\n    async copyQuery() {\n      const { queryEditor, onCopyQuery } = get();\n      if (!queryEditor) {\n        return;\n      }\n\n      const query = queryEditor.getValue();\n      onCopyQuery?.(query);\n      try {\n        await navigator.clipboard.writeText(query);\n      } catch (error) {\n        // eslint-disable-next-line no-console\n        console.warn('Failed to copy query!', error);\n      }\n    },\n    async prettifyEditors() {\n      const { queryEditor, headerEditor, variableEditor, onPrettifyQuery } =\n        get();\n\n      if (variableEditor) {\n        try {\n          const content = variableEditor.getValue();\n          const formatted = await formatJSONC(content);\n          if (formatted !== content) {\n            variableEditor.setValue(formatted);\n          }\n        } catch (error) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            'Parsing variables JSON failed, skip prettification.',\n            error,\n          );\n        }\n      }\n\n      if (headerEditor) {\n        try {\n          const content = headerEditor.getValue();\n          const formatted = await formatJSONC(content);\n          if (formatted !== content) {\n            headerEditor.setValue(formatted);\n          }\n        } catch (error) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            'Parsing headers JSON failed, skip prettification.',\n            error,\n          );\n        }\n      }\n\n      if (!queryEditor) {\n        return;\n      }\n      try {\n        const content = queryEditor.getValue();\n        const formatted = await onPrettifyQuery(content);\n        if (formatted !== content) {\n          queryEditor.setValue(formatted);\n        }\n      } catch (error) {\n        // eslint-disable-next-line no-console\n        console.warn('Parsing query failed, skip prettification.', error);\n      }\n    },\n    mergeQuery() {\n      const { queryEditor, documentAST, schema } = get();\n      const query = queryEditor?.getValue();\n      if (!documentAST || !query) {\n        return;\n      }\n      queryEditor!.setValue(print(mergeAst(documentAST, schema)));\n    },\n  };\n  return {\n    ...initial,\n    actions: $actions,\n  };\n};\n"],"names":["createEditorSlice","initial","set","get","setEditorValues","query","variables","headers","response","queryEditor","variableEditor","headerEditor","responseEditor","defaultHeaders","setValue","synchronizeActiveTabValues","tabsState","operationName","setPropertiesInActiveTab","getValue","$actions","addTab","onTabChange","tabs","activeTabIndex","actions","updatedValues","updated","createTab","length","storeTabs","changeTab","index","stop","moveTab","newOrder","activeTab","indexOf","closeTab","filter","_tab","i","Math","max","updateActiveTabValues","partialTab","setEditor","entries","Object","_key","value","newState","fromEntries","setOperationName","onEditOperationName","setShouldPersistHeaders","persist","storage","STORAGE_KEY","serializedTabs","serializeTabState","clearHeadersFromTabs","persistHeaders","toString","shouldPersistHeaders","store","debounce","setOperationFacts","documentAST","operations","copyQuery","onCopyQuery","navigator","clipboard","writeText","error","warn","prettifyEditors","onPrettifyQuery","content","formatted","formatJSONC","mergeQuery","schema","print","mergeAst"],"mappings":"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"}