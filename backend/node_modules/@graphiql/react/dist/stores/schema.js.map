{"version":3,"file":"schema.js","sources":["../../src/stores/schema.ts"],"sourcesContent":["import {\n  FetcherOpts,\n  fetcherReturnToPromise,\n  formatError,\n  formatResult,\n  isPromise,\n} from '@graphiql/toolkit';\nimport {\n  buildClientSchema,\n  getIntrospectionQuery,\n  GraphQLError,\n  GraphQLSchema,\n  IntrospectionQuery,\n} from 'graphql';\nimport type { Dispatch } from 'react';\nimport type { StateCreator } from 'zustand';\nimport type { SlicesWithActions, SchemaReference } from '../types';\nimport { tryParseJSONC } from '../utility';\n\ntype MaybeGraphQLSchema = GraphQLSchema | null | undefined;\n\ntype CreateSchemaSlice = (\n  initial: Pick<\n    SchemaSlice,\n    | 'inputValueDeprecation'\n    | 'introspectionQueryName'\n    | 'onSchemaChange'\n    | 'schemaDescription'\n  >,\n) => StateCreator<\n  SlicesWithActions,\n  [],\n  [],\n  SchemaSlice & {\n    actions: SchemaActions;\n  }\n>;\n\nexport const createSchemaSlice: CreateSchemaSlice = initial => (set, get) => ({\n  ...initial,\n\n  fetchError: null,\n  isIntrospecting: false,\n  schema: null,\n  /**\n   * Derive validation errors from the schema\n   */\n  validationErrors: [],\n  schemaReference: null,\n  requestCounter: 0,\n  shouldIntrospect: true,\n  actions: {\n    setSchemaReference(schemaReference) {\n      set({ schemaReference });\n    },\n    async introspect() {\n      const {\n        requestCounter,\n        shouldIntrospect,\n        onSchemaChange,\n        headerEditor,\n        fetcher,\n        inputValueDeprecation,\n        introspectionQueryName,\n        schemaDescription,\n      } = get();\n\n      /**\n       * Only introspect if there is no schema provided via props. If the\n       * prop is passed an introspection result, we do continue but skip the\n       * introspection request.\n       */\n      if (!shouldIntrospect) {\n        return;\n      }\n      const counter = requestCounter + 1;\n      set({ requestCounter: counter, isIntrospecting: true, fetchError: null });\n      try {\n        let headers: Record<string, unknown> | undefined;\n        try {\n          headers = tryParseJSONC(headerEditor?.getValue());\n        } catch (error) {\n          throw new Error(\n            `Introspection failed. Request headers ${error instanceof Error ? error.message : error}`,\n          );\n        }\n\n        const fetcherOpts: FetcherOpts = headers ? { headers } : {};\n        /**\n         * Get an introspection query for settings given via props\n         */\n        const introspectionQuery = getIntrospectionQuery({\n          inputValueDeprecation,\n          schemaDescription,\n        });\n\n        function doIntrospection(query: string) {\n          const fetch = fetcherReturnToPromise(\n            fetcher(\n              { query, operationName: introspectionQueryName },\n              fetcherOpts,\n            ),\n          );\n          if (!isPromise(fetch)) {\n            throw new TypeError(\n              'Fetcher did not return a Promise for introspection.',\n            );\n          }\n          return fetch;\n        }\n\n        const normalizedQuery =\n          introspectionQueryName === 'IntrospectionQuery'\n            ? introspectionQuery\n            : introspectionQuery.replace(\n                'query IntrospectionQuery',\n                `query ${introspectionQueryName}`,\n              );\n        let result = await doIntrospection(normalizedQuery);\n\n        if (typeof result !== 'object' || !('data' in result)) {\n          // Try the stock introspection query first, falling back on the\n          // sans-subscriptions query for services which do not yet support it.\n          result = await doIntrospection(\n            introspectionQuery.replace('subscriptionType { name }', ''),\n          );\n        }\n        set({ isIntrospecting: false });\n        let introspectionData: IntrospectionQuery | undefined;\n        if (result.data && '__schema' in result.data) {\n          introspectionData = result.data as IntrospectionQuery;\n        } else {\n          // handle as if it were an error if the fetcher response is not a string or response.data is not present\n          const responseString =\n            typeof result === 'string' ? result : formatResult(result);\n          set({ fetchError: responseString });\n        }\n        /**\n         * Don't continue if another introspection request has been started in\n         * the meantime or if there is no introspection data.\n         */\n        if (counter !== get().requestCounter || !introspectionData) {\n          return;\n        }\n        const newSchema = buildClientSchema(introspectionData);\n        set({ schema: newSchema });\n        onSchemaChange?.(newSchema);\n      } catch (error) {\n        /**\n         * Don't continue if another introspection request has been started in\n         * the meantime.\n         */\n        if (counter !== get().requestCounter) {\n          return;\n        }\n        if (error instanceof Error) {\n          delete error.stack;\n        }\n        set({\n          isIntrospecting: false,\n          fetchError: formatError(error),\n        });\n      }\n    },\n  },\n});\n\nexport interface SchemaSlice\n  extends Pick<\n    SchemaProps,\n    | 'inputValueDeprecation'\n    | 'introspectionQueryName'\n    | 'schemaDescription'\n    | 'onSchemaChange'\n  > {\n  /**\n   * Stores an error raised during introspecting or building the GraphQL schema\n   * from the introspection result.\n   */\n  fetchError: string | null;\n\n  /**\n   * If there currently is an introspection request in-flight.\n   */\n  isIntrospecting: boolean;\n\n  /**\n   * The current GraphQL schema.\n   */\n  schema: MaybeGraphQLSchema;\n\n  /**\n   * A list of errors from validating the current GraphQL schema. The schema is\n   * valid if and only if this list is empty.\n   */\n  validationErrors: readonly GraphQLError[];\n\n  /**\n   * The last type selected by the user.\n   */\n  schemaReference: SchemaReference | null;\n\n  /**\n   * A counter that is incremented each time introspection is triggered or the\n   * schema state is updated.\n   */\n  requestCounter: number;\n\n  /**\n   * `false` when `schema` is provided via `props` as `GraphQLSchema | null`\n   */\n  shouldIntrospect: boolean;\n}\n\nexport interface SchemaActions {\n  /**\n   * Trigger building the GraphQL schema. This might trigger an introspection\n   * request if no schema is passed via props and if using a schema is not\n   * explicitly disabled by passing `null` as value for the `schema` prop. If\n   * there is a schema (either fetched using introspection or passed via props)\n   * it will be validated, unless this is explicitly skipped using the\n   * `dangerouslyAssumeSchemaIsValid` prop.\n   */\n  introspect(): Promise<void>;\n\n  /**\n   * Set the current selected type.\n   */\n  setSchemaReference: Dispatch<SchemaReference>;\n}\n\nexport interface SchemaProps {\n  /**\n   * This prop can be used to skip validating the GraphQL schema. This applies\n   * to both schemas fetched via introspection and schemas explicitly passed\n   * via the `schema` prop.\n   *\n   * IMPORTANT NOTE: Without validating the schema, GraphiQL and its components\n   * are vulnerable to numerous exploits and might break. Only use this prop if\n   * you have full control over the schema passed to GraphiQL.\n   *\n   * @default false\n   */\n  dangerouslyAssumeSchemaIsValid?: boolean;\n\n  /**\n   * Invoked after a new GraphQL schema was built. This includes both fetching\n   * the schema via introspection and passing the schema using the `schema`\n   * prop.\n   * @param schema - The GraphQL schema that is now used for GraphiQL.\n   */\n  onSchemaChange?(schema: GraphQLSchema): void;\n\n  /**\n   * Explicitly provide the GraphiQL schema that shall be used for GraphiQL.\n   * If this props is...\n   * - ...passed and the value is a GraphQL schema, it will be validated and\n   *   then used for GraphiQL if it is valid.\n   * - ...passed and the value is the result of an introspection query, a\n   *   GraphQL schema will be built from this introspection data, it will be\n   *   validated, and then used for GraphiQL if it is valid.\n   * - ...set to `null`, no introspection request will be triggered and\n   *   GraphiQL will run without a schema.\n   * - ...set to `undefined` or not set at all, an introspection request will\n   *   be triggered. If this request succeeds, a GraphQL schema will be built\n   *   from the returned introspection data, it will be validated, and then\n   *   used for GraphiQL if it is valid. If this request fails, GraphiQL will\n   *   run without a schema.\n   */\n  schema?: GraphQLSchema | IntrospectionQuery | null;\n\n  /**\n   * Can be used to set the equally named option for introspecting a GraphQL\n   * server.\n   * @default false\n   * @see {@link https://github.com/graphql/graphql-js/blob/main/src/utilities/getIntrospectionQuery.ts|Utility for creating the introspection query}\n   */\n  inputValueDeprecation?: boolean;\n\n  /**\n   * Can be used to set a custom operation name for the introspection query.\n   * @default 'IntrospectionQuery'\n   */\n  introspectionQueryName?: string;\n\n  /**\n   * Can be used to set the equally named option for introspecting a GraphQL\n   * server.\n   * @default false\n   * @see {@link https://github.com/graphql/graphql-js/blob/main/src/utilities/getIntrospectionQuery.ts|Utility for creating the introspection query}\n   */\n  schemaDescription?: boolean;\n}\n"],"names":["createSchemaSlice","initial","set","get","fetchError","isIntrospecting","schema","validationErrors","schemaReference","requestCounter","shouldIntrospect","actions","setSchemaReference","introspect","onSchemaChange","headerEditor","fetcher","inputValueDeprecation","introspectionQueryName","schemaDescription","counter","doIntrospection","query","fetch","fetcherReturnToPromise","operationName","fetcherOpts","isPromise","TypeError","headers","tryParseJSONC","getValue","error","Error","message","introspectionQuery","getIntrospectionQuery","normalizedQuery","replace","result","introspectionData","data","responseString","formatResult","newSchema","buildClientSchema","stack","formatError"],"mappings":";;;AAsCO,MAAMA,oBAAuCC,CAAAA,YAAW,CAACC,KAAKC,SAAS;AAAA,EAC5E,GAAGF;AAAAA,EAEHG,YAAY;AAAA,EACZC,iBAAiB;AAAA,EACjBC,QAAQ;AAAA;AAAA;AAAA;AAAA,EAIRC,kBAAkB,CAAE;AAAA,EACpBC,iBAAiB;AAAA,EACjBC,gBAAgB;AAAA,EAChBC,kBAAkB;AAAA,EAClBC,SAAS;AAAA,IACPC,mBAAmBJ,iBAAiB;AAC9B,UAAA;AAAA,QAAEA;AAAAA,MAAAA,CAAiB;AAAA,IACzB;AAAA,IACA,MAAMK,aAAa;AACX,YAAA;AAAA,QACJJ;AAAAA,QACAC;AAAAA,QACAI;AAAAA,QACAC;AAAAA,QACAC;AAAAA,QACAC;AAAAA,QACAC;AAAAA,QACAC;AAAAA,UACEhB,IAAI;AAOR,UAAI,CAACO,kBAAkB;AACrB;AAAA,MAAA;AAEF,YAAMU,UAAUX,iBAAiB;AAC7B,UAAA;AAAA,QAAEA,gBAAgBW;AAAAA,QAASf,iBAAiB;AAAA,QAAMD,YAAY;AAAA,MAAA,CAAM;AACpE,UAAA;AAmBOiB,YAAAA,kBAAT,SAAyBC,OAAe;AAChCC,gBAAAA,QAAQC,uBACZR,QACE;AAAA,YAAEM;AAAAA,YAAOG,eAAeP;AAAAA,UAAuB,GAC/CQ,WACF,CACF;AACI,cAAA,CAACC,UAAUJ,KAAK,GAAG;AACf,kBAAA,IAAIK,UACR,qDACF;AAAA,UAAA;AAEKL,iBAAAA;AAAAA,QACT;AA/BIM,YAAAA;AACA,YAAA;AACQC,oBAAAA,cAAcf,6CAAcgB,UAAU;AAAA,iBACzCC,OAAO;AACR,gBAAA,IAAIC,MACR,yCAAyCD,iBAAiBC,QAAQD,MAAME,UAAUF,KAAK,EACzF;AAAA,QAAA;AAGF,cAAMN,cAA2BG,UAAU;AAAA,UAAEA;AAAAA,QAAAA,IAAY,CAAC;AAI1D,cAAMM,qBAAqBC,sBAAsB;AAAA,UAC/CnB;AAAAA,UACAE;AAAAA,QAAAA,CACD;AAiBKkB,cAAAA,kBACJnB,2BAA2B,uBACvBiB,qBACAA,mBAAmBG,QACjB,4BACA,SAASpB,sBAAsB,EACjC;AACFqB,YAAAA,SAAS,MAAMlB,gBAAgBgB,eAAe;AAElD,YAAI,OAAOE,WAAW,YAAY,EAAE,UAAUA,SAAS;AAGrDA,mBAAS,MAAMlB,gBACbc,mBAAmBG,QAAQ,6BAA6B,EAAE,CAC5D;AAAA,QAAA;AAEE,YAAA;AAAA,UAAEjC,iBAAiB;AAAA,QAAA,CAAO;AAC1BmC,YAAAA;AACJ,YAAID,OAAOE,QAAQ,cAAcF,OAAOE,MAAM;AAC5CD,8BAAoBD,OAAOE;AAAAA,QAAAA,OACtB;AAEL,gBAAMC,iBACJ,OAAOH,WAAW,WAAWA,SAASI,aAAaJ,MAAM;AACvD,cAAA;AAAA,YAAEnC,YAAYsC;AAAAA,UAAAA,CAAgB;AAAA,QAAA;AAMpC,YAAItB,YAAYjB,IAAAA,EAAMM,kBAAkB,CAAC+B,mBAAmB;AAC1D;AAAA,QAAA;AAEII,cAAAA,YAAYC,kBAAkBL,iBAAiB;AACjD,YAAA;AAAA,UAAElC,QAAQsC;AAAAA,QAAAA,CAAW;AACzB9B,yDAAiB8B;AAAAA,eACVZ,OAAO;AAKVZ,YAAAA,YAAYjB,IAAI,EAAEM,gBAAgB;AACpC;AAAA,QAAA;AAEF,YAAIuB,iBAAiBC,OAAO;AAC1B,iBAAOD,MAAMc;AAAAA,QAAAA;AAEX,YAAA;AAAA,UACFzC,iBAAiB;AAAA,UACjBD,YAAY2C,YAAYf,KAAK;AAAA,QAAA,CAC9B;AAAA,MAAA;AAAA,IACH;AAAA,EACF;AAEJ;"}