{"version":3,"file":"execution.js","sources":["../../src/stores/execution.ts"],"sourcesContent":["import {\n  Fetcher,\n  fillLeafs,\n  formatError,\n  formatResult,\n  GetDefaultFieldNamesFn,\n  isAsyncIterable,\n  isObservable,\n  Unsubscribable,\n} from '@graphiql/toolkit';\nimport { ExecutionResult, GraphQLError, print } from 'graphql';\nimport { getFragmentDependenciesForAST } from 'graphql-language-service';\nimport setValue from 'set-value';\nimport getValue from 'get-value';\n\nimport type { StateCreator } from 'zustand';\nimport { tryParseJSONC, Range } from '../utility';\nimport type { SlicesWithActions, MonacoEditor } from '../types';\n\nexport interface ExecutionSlice {\n  /**\n   * If there is currently a GraphQL request in-flight. For multipart\n   * requests like subscriptions, this will be `true` while fetching the\n   * first partial response and `false` while fetching subsequent batches.\n   * @default false\n   */\n  isFetching: boolean;\n\n  /**\n   * Represents an active GraphQL subscription.\n   *\n   * For multipart operations such as subscriptions, this\n   * will hold an `Unsubscribable` object while the request is in-flight. It\n   * remains non-null until the operation completes or is manually unsubscribed.\n   *\n   * @remarks Use `subscription?.unsubscribe()` to cancel the request.\n   * @default null\n   */\n  subscription: Unsubscribable | null;\n\n  /**\n   * The operation name that will be sent with all GraphQL requests.\n   * @default null\n   */\n  overrideOperationName: string | null;\n\n  /**\n   * A function to determine which field leafs are automatically added when\n   * trying to execute a query with missing selection sets. It will be called\n   * with the `GraphQLType` for which fields need to be added.\n   */\n  getDefaultFieldNames?: GetDefaultFieldNamesFn;\n\n  /**\n   * @default 0\n   */\n  queryId: number;\n\n  /**\n   * A function which accepts GraphQL HTTP parameters and returns a `Promise`,\n   * `Observable` or `AsyncIterable` that returns the GraphQL response in\n   * parsed JSON format.\n   *\n   * We suggest using the `createGraphiQLFetcher` utility from `@graphiql/toolkit`\n   * to create these fetcher functions.\n   *\n   * @see {@link https://graphiql-test.netlify.app/typedoc/modules/graphiql_toolkit.html#creategraphiqlfetcher-2|`createGraphiQLFetcher`}\n   */\n  fetcher: Fetcher;\n}\n\nexport interface ExecutionActions {\n  /**\n   * Start a GraphQL request based on the current editor contents.\n   */\n  run(): void;\n\n  /**\n   * Stop the GraphQL request that is currently in-flight.\n   */\n  stop(): void;\n}\n\nexport interface ExecutionProps\n  extends Pick<ExecutionSlice, 'getDefaultFieldNames' | 'fetcher'> {\n  /**\n   * This prop sets the operation name that is passed with a GraphQL request.\n   */\n  operationName?: string;\n}\n\ntype CreateExecutionSlice = (\n  initial: Pick<\n    ExecutionSlice,\n    'overrideOperationName' | 'getDefaultFieldNames' | 'fetcher'\n  >,\n) => StateCreator<\n  SlicesWithActions,\n  [],\n  [],\n  ExecutionSlice & {\n    actions: ExecutionActions;\n  }\n>;\n\nexport const createExecutionSlice: CreateExecutionSlice =\n  initial => (set, get) => {\n    function getAutoCompleteLeafs() {\n      const { queryEditor, schema, getDefaultFieldNames } = get();\n      if (!queryEditor) {\n        return;\n      }\n      const query = queryEditor.getValue();\n      const { insertions, result = '' } = fillLeafs(\n        schema,\n        query,\n        getDefaultFieldNames,\n      );\n      if (!insertions.length) {\n        return result;\n      }\n      const model = queryEditor.getModel()!;\n\n      // Save the current cursor position as an offset\n      const selection = queryEditor.getSelection()!;\n      const cursorIndex = model.getOffsetAt(selection.getPosition());\n\n      // Replace entire content\n      model.setValue(result);\n\n      let added = 0;\n      const decorations = insertions.map(({ index, string }) => {\n        const start = model.getPositionAt(index + added);\n        const end = model.getPositionAt(index + (added += string.length));\n        return {\n          range: new Range(\n            start.lineNumber,\n            start.column,\n            end.lineNumber,\n            end.column,\n          ),\n          options: {\n            className: 'auto-inserted-leaf',\n            hoverMessage: { value: 'Automatically added leaf fields' },\n            isWholeLine: false,\n          },\n        };\n      });\n\n      // Create a decoration collection (initially empty)\n      const decorationCollection = queryEditor.createDecorationsCollection([]);\n\n      // Apply decorations\n      decorationCollection.set(decorations);\n\n      // Clear decorations after 7 seconds\n      setTimeout(() => {\n        decorationCollection.clear();\n      }, 7000);\n\n      // Adjust the cursor position based on insertions\n      let newCursorIndex = cursorIndex;\n      for (const { index, string } of insertions) {\n        if (index < cursorIndex) {\n          newCursorIndex += string.length;\n        }\n      }\n\n      const newCursorPosition = model.getPositionAt(newCursorIndex);\n      queryEditor.setPosition(newCursorPosition);\n\n      return result;\n    }\n\n    return {\n      ...initial,\n      isFetching: false,\n      subscription: null,\n      queryId: 0,\n      actions: {\n        stop() {\n          set(({ subscription }) => {\n            subscription?.unsubscribe();\n            return { isFetching: false, subscription: null };\n          });\n        },\n        async run() {\n          const {\n            externalFragments,\n            headerEditor,\n            queryEditor,\n            responseEditor,\n            variableEditor,\n            actions,\n            operationName,\n            documentAST,\n            subscription,\n            overrideOperationName,\n            queryId,\n            fetcher,\n          } = get();\n          if (!queryEditor || !responseEditor) {\n            return;\n          }\n          // If there's an active subscription, unsubscribe it and return\n          if (subscription) {\n            actions.stop();\n            return;\n          }\n\n          function setResponse(value: string): void {\n            responseEditor?.setValue(value);\n            actions.updateActiveTabValues({ response: value });\n          }\n\n          function setError(error: Error, editor?: MonacoEditor): void {\n            if (!editor) {\n              return;\n            }\n            const name =\n              editor === variableEditor ? 'Variables' : 'Request headers';\n            // Need to format since the response editor uses `json` language\n            setResponse(formatError({ message: `${name} ${error.message}` }));\n          }\n\n          const newQueryId = queryId + 1;\n          set({ queryId: newQueryId });\n\n          // Use the edited query after autoCompleteLeafs() runs or,\n          // in case autoCompletion fails (the function returns undefined),\n          // the current query from the editor.\n          let query = getAutoCompleteLeafs() || queryEditor.getValue();\n\n          let variables: Record<string, unknown> | undefined;\n          try {\n            variables = tryParseJSONC(variableEditor?.getValue());\n          } catch (error) {\n            setError(error as Error, variableEditor);\n            return;\n          }\n          let headers: Record<string, unknown> | undefined;\n          try {\n            headers = tryParseJSONC(headerEditor?.getValue());\n          } catch (error) {\n            setError(error as Error, headerEditor);\n            return;\n          }\n          const fragmentDependencies = documentAST\n            ? getFragmentDependenciesForAST(documentAST, externalFragments)\n            : [];\n          if (fragmentDependencies.length) {\n            query +=\n              '\\n' + fragmentDependencies.map(node => print(node)).join('\\n');\n          }\n\n          setResponse('');\n          set({ isFetching: true });\n          try {\n            const fullResponse: ExecutionResult = {};\n            const handleResponse = (result: ExecutionResult) => {\n              // A different query was dispatched in the meantime, so don't\n              // show the results of this one.\n              if (newQueryId !== get().queryId) {\n                return;\n              }\n\n              let maybeMultipart = Array.isArray(result) ? result : false;\n              if (\n                !maybeMultipart &&\n                typeof result === 'object' &&\n                'hasNext' in result\n              ) {\n                maybeMultipart = [result];\n              }\n\n              if (maybeMultipart) {\n                for (const part of maybeMultipart) {\n                  mergeIncrementalResult(fullResponse, part);\n                }\n\n                set({ isFetching: false });\n                setResponse(formatResult(fullResponse));\n              } else {\n                set({ isFetching: false });\n                setResponse(formatResult(result));\n              }\n            };\n            const opName = overrideOperationName ?? operationName;\n            const fetch = fetcher(\n              { query, variables, operationName: opName },\n              { headers, documentAST },\n            );\n\n            const value = await fetch;\n            if (isObservable(value)) {\n              // If the fetcher returned an Observable, then subscribe to it, calling\n              // the callback on each next value and handling both errors and the\n              // completion of the Observable.\n              const newSubscription = value.subscribe({\n                next(result) {\n                  handleResponse(result);\n                },\n                error(error: Error) {\n                  set({ isFetching: false });\n                  setResponse(formatError(error));\n                  set({ subscription: null });\n                },\n                complete() {\n                  set({ isFetching: false, subscription: null });\n                },\n              });\n              set({ subscription: newSubscription });\n            } else if (isAsyncIterable(value)) {\n              const newSubscription = {\n                unsubscribe: () => value[Symbol.asyncIterator]().return?.(),\n              };\n              set({ subscription: newSubscription });\n              for await (const result of value) {\n                handleResponse(result);\n              }\n              set({ isFetching: false, subscription: null });\n            } else {\n              handleResponse(value);\n            }\n          } catch (error) {\n            set({ isFetching: false });\n            setResponse(formatError(error));\n            set({ subscription: null });\n          }\n        },\n      },\n    };\n  };\n\ninterface IncrementalResult {\n  data?: Record<string, unknown> | null;\n  errors?: ReadonlyArray<GraphQLError>;\n  extensions?: Record<string, unknown>;\n  hasNext?: boolean;\n  path?: ReadonlyArray<string | number>;\n  incremental?: ReadonlyArray<IncrementalResult>;\n  label?: string;\n  items?: ReadonlyArray<Record<string, unknown>> | null;\n  pending?: ReadonlyArray<{ id: string; path: ReadonlyArray<string | number> }>;\n  completed?: ReadonlyArray<{\n    id: string;\n    errors?: ReadonlyArray<GraphQLError>;\n  }>;\n  id?: string;\n  subPath?: ReadonlyArray<string | number>;\n}\n\nconst pathsMap = new WeakMap<\n  ExecutionResult,\n  Map<string, ReadonlyArray<string | number>>\n>();\n\n/**\n * @param executionResult - The complete execution result object which will be\n * mutated by merging the contents of the incremental result.\n * @param incrementalResult - The incremental result that will be merged into the\n * complete execution result.\n */\nfunction mergeIncrementalResult(\n  executionResult: IncrementalResult,\n  incrementalResult: IncrementalResult,\n): void {\n  let path: ReadonlyArray<string | number> | undefined = [\n    'data',\n    ...(incrementalResult.path ?? []),\n  ];\n\n  for (const result of [executionResult, incrementalResult]) {\n    if (result.pending) {\n      let paths = pathsMap.get(executionResult);\n      if (paths === undefined) {\n        paths = new Map();\n        pathsMap.set(executionResult, paths);\n      }\n\n      for (const { id, path: pendingPath } of result.pending) {\n        paths.set(id, ['data', ...pendingPath]);\n      }\n    }\n  }\n\n  const { items, data, id } = incrementalResult;\n  if (items) {\n    if (id) {\n      path = pathsMap.get(executionResult)?.get(id);\n      if (path === undefined) {\n        throw new Error('Invalid incremental delivery format.');\n      }\n\n      const list = getValue(executionResult, path.join('.'));\n      list.push(...items);\n    } else {\n      path = ['data', ...(incrementalResult.path ?? [])];\n      for (const item of items) {\n        setValue(executionResult, path.join('.'), item);\n        // Increment the last path segment (the array index) to merge the next item at the next index\n        // @ts-expect-error -- (path[path.length - 1] as number)++ breaks react compiler\n        path[path.length - 1]++;\n      }\n    }\n  }\n  if (data) {\n    if (id) {\n      path = pathsMap.get(executionResult)?.get(id);\n      if (path === undefined) {\n        throw new Error('Invalid incremental delivery format.');\n      }\n      const { subPath } = incrementalResult;\n      if (subPath !== undefined) {\n        path = [...path, ...subPath];\n      }\n    }\n    setValue(executionResult, path.join('.'), data, {\n      merge: true,\n    });\n  }\n\n  if (incrementalResult.errors) {\n    executionResult.errors ||= [];\n    (executionResult.errors as GraphQLError[]).push(\n      ...incrementalResult.errors,\n    );\n  }\n\n  if (incrementalResult.extensions) {\n    setValue(executionResult, 'extensions', incrementalResult.extensions, {\n      merge: true,\n    });\n  }\n\n  if (incrementalResult.incremental) {\n    for (const incrementalSubResult of incrementalResult.incremental) {\n      mergeIncrementalResult(executionResult, incrementalSubResult);\n    }\n  }\n\n  if (incrementalResult.completed) {\n    // Remove tracking and add additional errors\n    for (const { id: completedId, errors } of incrementalResult.completed) {\n      pathsMap.get(executionResult)?.delete(completedId);\n      if (errors) {\n        executionResult.errors ||= [];\n        (executionResult.errors as GraphQLError[]).push(...errors);\n      }\n    }\n  }\n}\n"],"names":["createExecutionSlice","initial","set","get","getAutoCompleteLeafs","queryEditor","schema","getDefaultFieldNames","query","getValue","insertions","result","fillLeafs","length","model","getModel","selection","getSelection","cursorIndex","getOffsetAt","getPosition","setValue","added","decorations","map","index","string","start","getPositionAt","end","range","Range","lineNumber","column","options","className","hoverMessage","value","isWholeLine","decorationCollection","createDecorationsCollection","setTimeout","clear","newCursorIndex","newCursorPosition","setPosition","isFetching","subscription","queryId","actions","stop","unsubscribe","run","externalFragments","headerEditor","responseEditor","variableEditor","operationName","documentAST","overrideOperationName","fetcher","setResponse","updateActiveTabValues","response","setError","error","editor","name","formatError","message","newQueryId","variables","tryParseJSONC","headers","fragmentDependencies","getFragmentDependenciesForAST","node","print","join","fullResponse","handleResponse","maybeMultipart","Array","isArray","part","mergeIncrementalResult","formatResult","opName","fetch","isObservable","newSubscription","subscribe","next","complete","isAsyncIterable","Symbol","asyncIterator","return","pathsMap","WeakMap","executionResult","incrementalResult","path","pending","paths","undefined","Map","id","pendingPath","items","data","Error","list","push","item","subPath","merge","errors","extensions","incremental","incrementalSubResult","completed","completedId","delete"],"mappings":"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"}