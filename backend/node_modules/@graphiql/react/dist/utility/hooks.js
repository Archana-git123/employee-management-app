import { c } from "react-compiler-runtime";
import { useRef, useState, useEffect } from "react";
import { debounce } from "./debounce.js";
import { useGraphiQL, useGraphiQLActions } from "../components/provider.js";
function useChangeHandler(callback, storageKey, tabProperty) {
  const $ = c(10);
  const {
    updateActiveTabValues
  } = useGraphiQLActions();
  let t0;
  if ($[0] !== tabProperty) {
    t0 = (state) => ({
      editor: state[tabProperty === "variables" ? "variableEditor" : "headerEditor"],
      storage: state.storage
    });
    $[0] = tabProperty;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const {
    editor,
    storage
  } = useGraphiQL(t0);
  let t1;
  let t2;
  if ($[2] !== callback || $[3] !== editor || $[4] !== storage || $[5] !== storageKey || $[6] !== tabProperty || $[7] !== updateActiveTabValues) {
    t1 = () => {
      if (!editor) {
        return;
      }
      const store = debounce(500, (value) => {
        if (storageKey === null) {
          return;
        }
        storage.set(storageKey, value);
      });
      const updateTab = debounce(100, (value_0) => {
        updateActiveTabValues({
          [tabProperty]: value_0
        });
      });
      const handleChange = (_event) => {
        const newValue = editor.getValue();
        store(newValue);
        updateTab(newValue);
        callback == null ? void 0 : callback(newValue);
      };
      const disposable = editor.getModel().onDidChangeContent(handleChange);
      return () => {
        disposable.dispose();
      };
    };
    t2 = [callback, editor, storageKey, tabProperty, updateActiveTabValues, storage];
    $[2] = callback;
    $[3] = editor;
    $[4] = storage;
    $[5] = storageKey;
    $[6] = tabProperty;
    $[7] = updateActiveTabValues;
    $[8] = t1;
    $[9] = t2;
  } else {
    t1 = $[8];
    t2 = $[9];
  }
  useEffect(t1, t2);
}
const useEditorState = (editor) => {
  const $ = c(12);
  let t0;
  if ($[0] !== editor) {
    t0 = (state) => state[`${editor}Editor`];
    $[0] = editor;
    $[1] = t0;
  } else {
    t0 = $[1];
  }
  const editorInstance = useGraphiQL(t0);
  const [value, setValue] = useState("");
  let t1;
  if ($[2] !== editorInstance) {
    t1 = editorInstance == null ? void 0 : editorInstance.getModel();
    $[2] = editorInstance;
    $[3] = t1;
  } else {
    t1 = $[3];
  }
  const model = t1;
  let t2;
  let t3;
  if ($[4] !== model) {
    t2 = () => {
      if (!model) {
        return;
      }
      const onChange = function onChange2() {
        setValue(model.getValue());
      };
      const disposable = model.onDidChangeContent(onChange);
      onChange();
      return () => {
        disposable.dispose();
      };
    };
    t3 = [model];
    $[4] = model;
    $[5] = t2;
    $[6] = t3;
  } else {
    t2 = $[5];
    t3 = $[6];
  }
  useEffect(t2, t3);
  let t4;
  if ($[7] !== model) {
    t4 = function handleChange2(newValue) {
      model.setValue(newValue);
    };
    $[7] = model;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  const handleChange = t4;
  let t5;
  if ($[9] !== handleChange || $[10] !== value) {
    t5 = [value, handleChange];
    $[9] = handleChange;
    $[10] = value;
    $[11] = t5;
  } else {
    t5 = $[11];
  }
  return t5;
};
const useOperationsEditorState = () => {
  return useEditorState("query");
};
const useVariablesEditorState = () => {
  return useEditorState("variable");
};
const useHeadersEditorState = () => {
  return useEditorState("header");
};
function useOptimisticState(t0) {
  const $ = c(12);
  const [upstreamState, upstreamSetState] = t0;
  let t1;
  if ($[0] !== upstreamState) {
    t1 = {
      pending: null,
      last: upstreamState
    };
    $[0] = upstreamState;
    $[1] = t1;
  } else {
    t1 = $[1];
  }
  const lastStateRef = useRef(t1);
  const [state, setOperationsText] = useState(upstreamState);
  let t2;
  let t3;
  if ($[2] !== state || $[3] !== upstreamSetState || $[4] !== upstreamState) {
    t2 = () => {
      if (lastStateRef.current.last === upstreamState) {
        return;
      }
      lastStateRef.current.last = upstreamState;
      if (lastStateRef.current.pending === null) {
        setOperationsText(upstreamState);
        return;
      }
      if (lastStateRef.current.pending === upstreamState) {
        lastStateRef.current.pending = null;
        if (upstreamState !== state) {
          lastStateRef.current.pending = state;
          upstreamSetState(state);
        }
        return;
      }
      lastStateRef.current.pending = null;
      setOperationsText(upstreamState);
    };
    t3 = [upstreamState, state, upstreamSetState];
    $[2] = state;
    $[3] = upstreamSetState;
    $[4] = upstreamState;
    $[5] = t2;
    $[6] = t3;
  } else {
    t2 = $[5];
    t3 = $[6];
  }
  useEffect(t2, t3);
  let t4;
  if ($[7] !== upstreamSetState) {
    t4 = (newState) => {
      setOperationsText(newState);
      if (lastStateRef.current.pending === null && lastStateRef.current.last !== newState) {
        lastStateRef.current.pending = newState;
        upstreamSetState(newState);
      }
    };
    $[7] = upstreamSetState;
    $[8] = t4;
  } else {
    t4 = $[8];
  }
  const setState = t4;
  let t5;
  if ($[9] !== setState || $[10] !== state) {
    t5 = [state, setState];
    $[9] = setState;
    $[10] = state;
    $[11] = t5;
  } else {
    t5 = $[11];
  }
  return t5;
}
const useDidUpdate = (fn, dependencies) => {
  const $ = c(4);
  const didMountRef = useRef(false);
  let t0;
  let t1;
  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
    t0 = () => () => {
      didMountRef.current = false;
    };
    t1 = [];
    $[0] = t0;
    $[1] = t1;
  } else {
    t0 = $[0];
    t1 = $[1];
  }
  useEffect(t0, t1);
  let t2;
  if ($[2] !== fn) {
    t2 = () => {
      if (didMountRef.current) {
        return fn();
      }
      didMountRef.current = true;
    };
    $[2] = fn;
    $[3] = t2;
  } else {
    t2 = $[3];
  }
  useEffect(t2, dependencies);
};
export {
  useChangeHandler,
  useDidUpdate,
  useEditorState,
  useHeadersEditorState,
  useOperationsEditorState,
  useOptimisticState,
  useVariablesEditorState
};
//# sourceMappingURL=hooks.js.map
