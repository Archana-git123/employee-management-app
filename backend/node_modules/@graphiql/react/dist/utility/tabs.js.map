{"version":3,"file":"tabs.js","sources":["../../src/utility/tabs.ts"],"sourcesContent":["'use no memo'; // can't figure why it isn't optimized\n\nimport { STORAGE_KEY } from '../constants';\nimport type { AllSlices } from '../types';\n\nexport interface TabDefinition {\n  /**\n   * The contents of the operation editor of this tab.\n   */\n  query: string | null;\n  /**\n   * The contents of the variables editor of this tab.\n   */\n  variables?: string | null;\n  /**\n   * The contents of the request headers editor of this tab.\n   */\n  headers?: string | null;\n}\n\n/**\n * This object describes the state of a single tab.\n */\nexport interface TabState extends TabDefinition {\n  /**\n   * A GUID value generated when the tab was created.\n   */\n  id: string;\n\n  /**\n   * A hash that is unique for a combination of the contents of the query\n   * editor, the variables editor and the request headers editor (i.e., all the editor\n   * where the contents are persisted in storage).\n   */\n  hash: string;\n\n  /**\n   * The title of the tab shown in the tab element.\n   */\n  title: string;\n\n  /**\n   * The operation name derived from the contents of the operation editor of this\n   * tab.\n   */\n  operationName: string | null;\n\n  /**\n   * The contents of the response editor of this tab.\n   */\n  response: string | null;\n}\n\n/**\n * This object describes the state of all tabs.\n */\nexport type TabsState = {\n  /**\n   * A list of state objects for each tab.\n   */\n  tabs: TabState[];\n  /**\n   * The index of the currently active tab with regards to the `tabs` list of\n   * this object.\n   */\n  activeTabIndex: number;\n};\n\nexport function getDefaultTabState({\n  defaultQuery,\n  defaultHeaders,\n  headers,\n  query,\n  variables,\n  defaultTabs = [\n    {\n      query: query ?? defaultQuery,\n      variables,\n      headers: headers ?? defaultHeaders,\n    },\n  ],\n  shouldPersistHeaders,\n  storage,\n}: {\n  defaultQuery: string;\n  defaultHeaders?: string;\n  headers: string | null;\n  defaultTabs?: TabDefinition[];\n  query: string | null;\n  variables: string | null;\n  shouldPersistHeaders?: boolean;\n  storage: AllSlices['storage'];\n}) {\n  const storedState = storage.get(STORAGE_KEY.tabs);\n  try {\n    if (!storedState) {\n      throw new Error('Storage for tabs is empty');\n    }\n    const parsed = JSON.parse(storedState);\n    // if headers are not persisted, do not derive the hash using default headers state\n    // or else you will get new tabs on every refresh\n    const headersForHash = shouldPersistHeaders ? headers : undefined;\n    if (isTabsState(parsed)) {\n      const expectedHash = hashFromTabContents({\n        query,\n        variables,\n        headers: headersForHash,\n      });\n      let matchingTabIndex = -1;\n\n      for (let index = 0; index < parsed.tabs.length; index++) {\n        const tab = parsed.tabs[index]!;\n        tab.hash = hashFromTabContents({\n          query: tab.query,\n          variables: tab.variables,\n          headers: tab.headers,\n        });\n        if (tab.hash === expectedHash) {\n          matchingTabIndex = index;\n        }\n      }\n\n      if (matchingTabIndex >= 0) {\n        parsed.activeTabIndex = matchingTabIndex;\n      } else {\n        const operationName = query ? fuzzyExtractOperationName(query) : null;\n        parsed.tabs.push({\n          id: guid(),\n          hash: expectedHash,\n          title: operationName || DEFAULT_TITLE,\n          query,\n          variables,\n          headers,\n          operationName,\n          response: null,\n        });\n        parsed.activeTabIndex = parsed.tabs.length - 1;\n      }\n\n      return parsed;\n    }\n    throw new Error('Storage for tabs is invalid');\n  } catch {\n    return {\n      activeTabIndex: 0,\n      tabs: defaultTabs.map(createTab),\n    };\n  }\n}\n\nfunction isTabsState(obj: any): obj is TabsState {\n  return (\n    obj &&\n    typeof obj === 'object' &&\n    !Array.isArray(obj) &&\n    hasNumberKey(obj, 'activeTabIndex') &&\n    'tabs' in obj &&\n    Array.isArray(obj.tabs) &&\n    obj.tabs.every(isTabState)\n  );\n}\n\nfunction isTabState(obj: any): obj is TabState {\n  // We don't persist the hash, so we skip the check here\n  return (\n    obj &&\n    typeof obj === 'object' &&\n    !Array.isArray(obj) &&\n    hasStringKey(obj, 'id') &&\n    hasStringKey(obj, 'title') &&\n    hasStringOrNullKey(obj, 'query') &&\n    hasStringOrNullKey(obj, 'variables') &&\n    hasStringOrNullKey(obj, 'headers') &&\n    hasStringOrNullKey(obj, 'operationName') &&\n    hasStringOrNullKey(obj, 'response')\n  );\n}\n\nfunction hasNumberKey(obj: Record<string, any>, key: string) {\n  return key in obj && typeof obj[key] === 'number';\n}\n\nfunction hasStringKey(obj: Record<string, any>, key: string) {\n  return key in obj && typeof obj[key] === 'string';\n}\n\nfunction hasStringOrNullKey(obj: Record<string, any>, key: string) {\n  return key in obj && (typeof obj[key] === 'string' || obj[key] === null);\n}\n\nexport function serializeTabState(\n  tabState: TabsState,\n  shouldPersistHeaders = false,\n) {\n  return JSON.stringify(tabState, (key, value) =>\n    key === 'hash' ||\n    key === 'response' ||\n    (!shouldPersistHeaders && key === 'headers')\n      ? null\n      : value,\n  );\n}\n\nexport function createTab({\n  query = null,\n  variables = null,\n  headers = null,\n}: Partial<TabDefinition> = {}): TabState {\n  const operationName = query ? fuzzyExtractOperationName(query) : null;\n  return {\n    id: guid(),\n    hash: hashFromTabContents({ query, variables, headers }),\n    title: operationName || DEFAULT_TITLE,\n    query,\n    variables,\n    headers,\n    operationName,\n    response: null,\n  };\n}\n\nexport function setPropertiesInActiveTab(\n  state: TabsState,\n  partialTab: Partial<Omit<TabState, 'id' | 'hash' | 'title'>>,\n): TabsState {\n  return {\n    ...state,\n    tabs: state.tabs.map((tab, index) => {\n      if (index !== state.activeTabIndex) {\n        return tab;\n      }\n      const newTab = { ...tab, ...partialTab };\n      return {\n        ...newTab,\n        hash: hashFromTabContents(newTab),\n        title:\n          newTab.operationName ||\n          (newTab.query\n            ? fuzzyExtractOperationName(newTab.query)\n            : undefined) ||\n          DEFAULT_TITLE,\n      };\n    }),\n  };\n}\n\nfunction guid(): string {\n  const s4 = () => {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .slice(1);\n  };\n  // return id of format 'aaaaaaaa'-'aaaa'-'aaaa'-'aaaa'-'aaaaaaaaaaaa'\n  return `${s4()}${s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;\n}\n\nfunction hashFromTabContents(args: {\n  query: string | null;\n  variables?: string | null;\n  headers?: string | null;\n}): string {\n  return [args.query ?? '', args.variables ?? '', args.headers ?? ''].join('|');\n}\n\nexport function fuzzyExtractOperationName(str: string): string | null {\n  const regex = /^(?!#).*(query|subscription|mutation)\\s+([a-zA-Z0-9_]+)/m;\n\n  const match = regex.exec(str);\n\n  return match?.[2] ?? null;\n}\n\nexport function clearHeadersFromTabs(storage: AllSlices['storage']) {\n  const persistedTabs = storage.get(STORAGE_KEY.tabs);\n  if (persistedTabs) {\n    const parsedTabs = JSON.parse(persistedTabs);\n    storage.set(\n      STORAGE_KEY.tabs,\n      JSON.stringify(parsedTabs, (key, value) =>\n        key === 'headers' ? null : value,\n      ),\n    );\n  }\n}\n\nconst DEFAULT_TITLE = '<untitled>';\n"],"names":["getDefaultTabState","defaultQuery","defaultHeaders","headers","query","variables","defaultTabs","shouldPersistHeaders","storage","storedState","get","STORAGE_KEY","tabs","Error","parsed","JSON","parse","headersForHash","undefined","isTabsState","expectedHash","hashFromTabContents","matchingTabIndex","index","length","tab","hash","activeTabIndex","operationName","fuzzyExtractOperationName","push","id","guid","title","DEFAULT_TITLE","response","map","createTab","obj","Array","isArray","hasNumberKey","every","isTabState","hasStringKey","hasStringOrNullKey","key","serializeTabState","tabState","stringify","value","setPropertiesInActiveTab","state","partialTab","newTab","s4","Math","floor","random","toString","slice","args","join","str","regex","match","exec","clearHeadersFromTabs","persistedTabs","parsedTabs","set"],"mappings":"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"}