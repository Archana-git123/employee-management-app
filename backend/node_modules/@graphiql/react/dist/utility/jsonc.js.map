{"version":3,"file":"jsonc.js","sources":["../../src/utility/jsonc.ts"],"sourcesContent":["import {\n  parse as jsoncParse,\n  ParseError,\n  printParseErrorCode,\n} from 'jsonc-parser';\n\nexport async function formatJSONC(content: string): Promise<string> {\n  // We don't need to load Prettier initially; it's only used when the 'Format Query' button or shortcut is triggered\n  const [\n    prettier,\n    // @ts-expect-error â€“ no types\n    { printers },\n    { parsers },\n  ] = await Promise.all([\n    import('prettier/standalone'),\n    import('prettier/plugins/estree'),\n    import('prettier/parser-babel'),\n  ]);\n\n  return prettier.format(content, {\n    parser: 'jsonc',\n    plugins: [\n      // Fix: Couldn't find plugin for AST format \"estree\"\n      { printers },\n      // @ts-expect-error -- Fix Couldn't resolve parser \"jsonc\"\n      { parsers },\n    ],\n    // always split into new lines, e.g. {\"foo\":true} => {\\n  \"foo\": true\\n}\n    printWidth: 0,\n  });\n}\n\nconst formatter = new Intl.ListFormat('en', {\n  style: 'long',\n  type: 'conjunction', // uses \"and\"\n});\n\nexport function parseJSONC(content: string) {\n  const errors: ParseError[] = [];\n\n  const parsed: undefined | Record<string, unknown> = jsoncParse(\n    content,\n    errors,\n    {\n      allowTrailingComma: true,\n      allowEmptyContent: true,\n    },\n  );\n  if (errors.length) {\n    const output = formatter.format(\n      errors.map(({ error }) => printParseErrorCode(error)),\n    );\n    throw new SyntaxError(output);\n  }\n  return parsed;\n}\n\nexport function tryParseJSONC(json = '') {\n  let parsed: Record<string, unknown> | undefined;\n  try {\n    parsed = parseJSONC(json);\n  } catch (error) {\n    throw new Error(\n      `are invalid JSON: ${error instanceof Error ? error.message : error}.`,\n    );\n  }\n  if (!parsed) {\n    return;\n  }\n  const isObject = typeof parsed === 'object' && !Array.isArray(parsed);\n  if (!isObject) {\n    throw new TypeError('are not a JSON object.');\n  }\n  return parsed;\n}\n"],"names":["formatJSONC","content","prettier","printers","parsers","Promise","all","format","parser","plugins","printWidth","formatter","Intl","ListFormat","style","type","parseJSONC","errors","parsed","jsoncParse","allowTrailingComma","allowEmptyContent","length","output","map","error","printParseErrorCode","SyntaxError","tryParseJSONC","json","Error","message","isObject","Array","isArray","TypeError"],"mappings":";AAMA,eAAsBA,YAAYC,SAAkC;AAE5D,QAAA;AAAA,IACJC;AAAAA;AAAAA,IAEA;AAAA,MAAEC;AAAAA,IAAS;AAAA,IACX;AAAA,MAAEC;AAAAA,IAAAA;AAAAA,EAAQ,IACR,MAAMC,QAAQC,IAAI,CACpB,OAAO,qBAAqB,GAC5B,OAAO,yBAAyB,GAChC,OAAO,uBAAuB,CAAC,CAChC;AAEMJ,SAAAA,SAASK,OAAON,SAAS;AAAA,IAC9BO,QAAQ;AAAA,IACRC,SAAS;AAAA;AAAA,MAEP;AAAA,QAAEN;AAAAA,MAAS;AAAA;AAAA,MAEX;AAAA,QAAEC;AAAAA,MAAAA;AAAAA,IAAS;AAAA;AAAA,IAGbM,YAAY;AAAA,EAAA,CACb;AACH;AAEA,MAAMC,YAAY,IAAIC,KAAKC,WAAW,MAAM;AAAA,EAC1CC,OAAO;AAAA,EACPC,MAAM;AAAA;AACR,CAAC;AAEM,SAASC,WAAWf,SAAiB;AAC1C,QAAMgB,SAAuB,CAAE;AAEzBC,QAAAA,SAA8CC,MAClDlB,SACAgB,QACA;AAAA,IACEG,oBAAoB;AAAA,IACpBC,mBAAmB;AAAA,EAAA,CAEvB;AACA,MAAIJ,OAAOK,QAAQ;AACjB,UAAMC,SAASZ,UAAUJ,OACvBU,OAAOO,IAAI,CAAC;AAAA,MAAEC;AAAAA,IAAAA,MAAYC,oBAAoBD,KAAK,CAAC,CACtD;AACM,UAAA,IAAIE,YAAYJ,MAAM;AAAA,EAAA;AAEvBL,SAAAA;AACT;AAEgBU,SAAAA,cAAcC,OAAO,IAAI;AACnCX,MAAAA;AACA,MAAA;AACFA,aAASF,WAAWa,IAAI;AAAA,WACjBJ,OAAO;AACR,UAAA,IAAIK,MACR,qBAAqBL,iBAAiBK,QAAQL,MAAMM,UAAUN,KAAK,GACrE;AAAA,EAAA;AAEF,MAAI,CAACP,QAAQ;AACX;AAAA,EAAA;AAEF,QAAMc,WAAW,OAAOd,WAAW,YAAY,CAACe,MAAMC,QAAQhB,MAAM;AACpE,MAAI,CAACc,UAAU;AACP,UAAA,IAAIG,UAAU,wBAAwB;AAAA,EAAA;AAEvCjB,SAAAA;AACT;"}